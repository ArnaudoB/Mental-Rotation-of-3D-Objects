<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mental Rotation (Shepard–Metzler style) — Full 3D Replica</title>
  <style>
    :root{
      --bg:#0b0d10; --panel:#121720; --ink:#e8eefc; --muted:#9fb0d0; --accent:#6aa3ff; --ok:#53d17a; --bad:#ff6a6a;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink);}
    header{padding:16px 20px;border-bottom:1px solid #1c2330;background:linear-gradient(180deg,#0b0d10,#0b0d10 60%,#0e131b);} 
    h1{margin:4px 0 0;font-size:20px;letter-spacing:.2px}
    .wrap{max-width:1100px;margin:0 auto;padding:20px;}
    .grid{display:grid;gap:16px;grid-template-columns:1fr;}
    @media (min-width: 980px){.grid{grid-template-columns: 320px 1fr;}}
    .card{background:var(--panel);border:1px solid #1a2230;border-radius:16px;padding:16px;}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    label{font-size:14px;color:var(--muted)}
    input,select,button{background:#0e1420;color:var(--ink);border:1px solid #1a2230;border-radius:10px;padding:10px 12px;font-size:14px}
    input:disabled,select:disabled,button:disabled{opacity:.6}
    button.primary{background:var(--accent);border-color:#2a62ff;color:white;font-weight:600}
    button.good{background:var(--ok);border-color:#1f9c49;color:#04150b}
    button.bad{background:#2c1414;border-color:#552626;color:#ffbdbd}
    .muted{color:var(--muted);font-size:13px}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #263147;background:#0f1520;color:var(--muted);font-size:12px}
    canvas.stage{width:100%;aspect-ratio:3/2;background:#0b0f18;border:1px solid #1a2230;border-radius:12px;display:block}
    .stage-wrap{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, monospace;background:#0b0f18;border:1px solid #1a2230;padding:2px 6px;border-radius:6px}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{border-bottom:1px solid #1a2230;padding:8px 6px;text-align:right}
    th:nth-child(1),td:nth-child(1){text-align:left}
    .ok{color:var(--ok)}
    .err{color:var(--bad)}
    footer{opacity:.8;font-size:12px;text-align:center;padding:20px}
    .sep{height:1px;background:#1a2230;margin:6px 0 12px}
  </style>
  <!-- Chart.js for interactive RT vs angle plot -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header>
    <div class="wrap row" style="justify-content:space-between">
      <div>
        <div class="pill">3D replica</div>
        <h1>Mental Rotation Task — Shepard & Metzler (Interactive)</h1>
      </div>
      <div class="muted">Keys: <span class="kbd">S</span> = "Same", <span class="kbd">D</span> = "Different"</div>
    </div>
  </header>

  <div class="wrap grid">
    <section class="card">
      <h3 style="margin:6px 0 12px">Experiment setup</h3>
      <div class="row" style="margin-bottom:10px">
        <label for="pid">Participant ID</label>
        <input id="pid" placeholder="e.g., X21-001" />
      </div>
      <div class="row" style="margin-bottom:10px">
        <label for="ntrials">Trials</label>
        <input id="ntrials" type="number" min="10" value="80" style="width:100px"/>
        <label for="anglesel">Angles (deg)</label>
        <select id="anglesel" multiple size="6" style="min-width:160px">
          <option>0</option><option>20</option><option>40</option><option>60</option><option>80</option>
          <option>100</option><option>120</option><option>140</option><option>160</option><option>180</option>
        </select>
      </div>
      <div class="row" style="margin-bottom:10px">
        <label>Conditions</label>
        <label class="row"><input id="cond-same" type="checkbox" checked/> Same (rotation)</label>
        <label class="row"><input id="cond-diff" type="checkbox" checked/> Different (mirror)</label>
      </div>
      <div class="row" style="gap:8px">
        <button id="btn-shape">Regenerate base shape</button>
        <button id="btn-practice">Practice: 6 trials</button>
        <button id="btn-start" class="primary">Start experiment</button>
      </div>
      <div class="sep"></div>
      <div class="muted" id="status">Ready. Generate a base shape or start directly.</div>
    </section>

    <section class="card">
      <div class="stage-wrap">
        <canvas id="canvasL" class="stage" width="600" height="400"></canvas>
        <canvas id="canvasR" class="stage" width="600" height="400"></canvas>
      </div>
      <div class="row" style="margin-top:12px; gap:8px">
        <button id="btn-same" class="good">Same (S)</button>
        <button id="btn-diff" class="bad">Different (D)</button>
        <div class="pill" id="trialpill">Trial: –</div>
        <div class="pill" id="anglepill">Angle: –</div>
        <div class="pill" id="condpill">Condition: –</div>
        <div class="muted" id="feedback"></div>
      </div>
    </section>

    <section class="card" style="grid-column:1 / -1">
      <h3 style="margin:6px 0 12px">Results</h3>
      <div id="summary" class="muted">Run some trials to see per-angle reaction times and regression.</div>
      <div id="tables"></div>
      <div style="margin-top:14px">
        <canvas id="chartRT" height="220" aria-label="RT vs Angle plot"></canvas>
      </div>
      <div class="row" style="margin-top:10px; gap:8px">
        <button id="btn-export">Export CSV</button>
        <a id="dl" class="pill" href="#" download style="display:none">Download CSV</a>
      </div>
    </section>
  </div>

  <footer>Built with plain HTML/JS/CSS. Adds pseudo-3D perspective and full experimental logic (RT, regression, CSV export, interactive plot).</footer>

<script>
// ---------- Utilities ----------
function randChoice(a){return a[Math.floor(Math.random()*a.length)]}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
const now=()=>performance.now();

// ---------- Shape generation ----------
function genPolyomino(n=10){const dirs=[[1,0],[-1,0],[0,1],[0,-1]];let path=[{x:0,y:0}],cells=new Set(['0,0']);let spins=0;while(path.length<n&&spins<5000){spins++;const [dx,dy]=randChoice(dirs);let nx=path.at(-1).x+dx,ny=path.at(-1).y+dy;const k=`${nx},${ny}`;if(path.length>1){const p2=path.at(-2);if(p2.x===nx&&p2.y===ny)continue;}if(!cells.has(k)){cells.add(k);path.push({x:nx,y:ny})}}if(path.length<n)return genPolyomino(n);const minx=Math.min(...path.map(p=>p.x)),miny=Math.min(...path.map(p=>p.y));return path.map(p=>({x:p.x-minx,y:p.y-miny}))}
function mirrorX(p){const maxx=Math.max(...p.map(c=>c.x));return p.map(c=>({x:maxx-c.x,y:c.y}))}

// ---------- 3D projection & drawing ----------
function project3D(x,y,z,angleX,angleY,scale){const rx=x,ry=y,rz=z;const radX=angleX*Math.PI/180,radY=angleY*Math.PI/180;const cx=Math.cos(radX),sx=Math.sin(radX),cy=Math.cos(radY),sy=Math.sin(radY);const y2=ry*cx-rz*sx;const z2=ry*sx+rz*cx;const x2=rx*cy+z2*sy;const z3=-rx*sy+z2*cy;return{x:x2*scale,y:y2*scale,z:z3*scale}}
function draw3D(ctx, poly, {angle=0, offsetX, offsetY, scale=24}){
  ctx.save();
  ctx.translate(offsetX, offsetY);
  // compute a deterministic shallow depth so the object has structure (no randomness per frame)
  const mx = poly.reduce((s,p)=>s+p.x,0)/poly.length;
  const my = poly.reduce((s,p)=>s+p.y,0)/poly.length;
  const depth = poly.map(p=>({x:p.x, y:p.y, z: 0.35*(p.x-mx) - 0.25*(p.y-my)}));
  // project each square's anchor and keep z for painter's ordering
  let squares = depth.map(p=>{
    const pt = project3D(p.x-2.5, p.y-2.5, p.z, 30, angle, scale);
    return {x: pt.x, y: pt.y, z: pt.z};
  });
  // draw far → near for nicer occlusion
  squares.sort((a,b)=>a.z-b.z);
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = '#bcd2ff';
  ctx.fillStyle = 'rgba(106,163,255,0.55)'; // more opaque so boxes read as solid
  for (const s of squares){
    ctx.beginPath();
    ctx.rect(s.x, s.y, scale, scale);
    ctx.fill();
    ctx.stroke();
  }
  ctx.restore();
}));const pts=depth.map(p=>project3D(p.x-2.5,p.y-2.5,p.z,30,angle,scale));ctx.beginPath();ctx.fillStyle='rgba(106,163,255,0.15)';ctx.strokeStyle='#7eb4ff';for(const pt of pts){ctx.rect(pt.x,pt.y,scale,scale)}ctx.fill();ctx.stroke();ctx.restore()}
function center(canvas){
  const s = Math.min(canvas.width, canvas.height) / 8; // bigger boxes, still safe
  return {offsetX: canvas.width/2, offsetY: canvas.height/2, scale: s};
}}

// ---------- Experiment state ----------
const ANGLE_DEFAULTS=[0,20,40,60,80,100,120,140,160,180];
let BASE=genPolyomino(10),MIRROR=mirrorX(BASE);
const canvasL=document.getElementById('canvasL'),canvasR=document.getElementById('canvasR');
const ctxL=canvasL.getContext('2d'),ctxR=canvasR.getContext('2d');
const state={trial:0,total:0,angles:[...ANGLE_DEFAULTS],allowSame:true,allowDiff:true,data:[],rtStart:null,angle:0,condition:null};
let rtChart=null;

// ---------- Core flow ----------
function clear(){ctxL.clearRect(0,0,canvasL.width,canvasL.height);ctxR.clearRect(0,0,canvasR.width,canvasR.height)}
function ui(id){return document.getElementById(id)}
function newTrial(){if(state.trial>=state.total)return finish();state.trial++;const angle=randChoice(state.angles);const cond=(Math.random()<0.5?'same':'diff');state.condition=cond;state.angle=angle;clear();draw3D(ctxL,BASE,{angle:0,...center(canvasL)});draw3D(ctxR,cond==='same'?BASE:MIRROR,{angle,...center(canvasR)});state.rtStart=now();ui('trialpill').textContent=`Trial: ${state.trial}/${state.total}`;ui('anglepill').textContent=`Angle: ${angle}°`;ui('condpill').textContent=`Condition: ${cond}`;ui('feedback').textContent='';}
function respond(ans){if(!state.rtStart)return;const rt=now()-state.rtStart;const correct=(ans===state.condition);state.data.push({pid:ui('pid').value.trim()||'NA',trial:state.trial,t:Date.now(),angle:state.angle,cond:state.condition,answer:ans,correct:correct?1:0,rt_ms:Math.round(rt)});ui('feedback').innerHTML=correct?`<span class='ok'>Correct</span> (${Math.round(rt)} ms)`: `<span class='err'>Wrong</span> (${Math.round(rt)} ms)`;state.rtStart=null;setTimeout(newTrial,400)}
function finish(){ui('status').textContent=`Finished ${state.data.length} trials.`;summarize()}

// ---------- Stats ----------
const mean=a=>a.reduce((s,x)=>s+x,0)/a.length;const sd=a=>{const m=mean(a);return Math.sqrt(mean(a.map(x=>(x-m)**2)))}
function linreg(x,y){const mx=mean(x),my=mean(y);let num=0,den=0,sst=0;for(let i=0;i<x.length;i++){const dx=x[i]-mx,dy=y[i]-my;num+=dx*dy;den+=dx*dx;sst+=(y[i]-my)**2;}const b=den===0?0:num/den;const a=my-b*mx;let ssr=0;for(let i=0;i<x.length;i++){const yhat=a+b*x[i];ssr+=(yhat-my)**2;}return{a,b,r2: sst===0?0:ssr/sst}}

function summarize(){
  // table + regression (SAME & correct)
  const sameCorrect=state.data.filter(d=>d.cond==='same'&&d.correct===1);
  if(!sameCorrect.length){ui('summary').textContent='No correct SAME trials yet.';ui('tables').innerHTML='';if(rtChart){rtChart.destroy();rtChart=null;}return}
  const byAngle=new Map();
  for(const d of sameCorrect){if(!byAngle.has(d.angle))byAngle.set(d.angle,[]);byAngle.get(d.angle).push(d.rt_ms)}
  const rows=[...byAngle.entries()].map(([ang,list])=>({angle: +ang, n:list.length, mean: mean(list), sd: sd(list)})).sort((a,b)=>a.angle-b.angle);
  const xs=rows.map(r=>r.angle), ys=rows.map(r=>r.mean);
  const {a,b,r2}=linreg(xs,ys);
  ui('summary').textContent=`Same & correct: ${sameCorrect.length}. Regression RT=a+b·θ → a=${a.toFixed(1)}ms, b=${b.toFixed(2)}ms/deg, R²=${r2.toFixed(3)}.`;
  ui('tables').innerHTML='<table><thead><tr><th>Angle (°)</th><th>N</th><th>Mean RT (ms)</th><th>SD (ms)</th></tr></thead><tbody>'+
    rows.map(r=>`<tr><td>${r.angle}</td><td>${r.n}</td><td>${r.mean.toFixed(1)}</td><td>${r.sd.toFixed(1)}</td></tr>`).join('')+
    '</tbody></table>';

  // Interactive plot using Chart.js
  const ctxPlot=document.getElementById('chartRT').getContext('2d');
  if(rtChart){rtChart.destroy();}
  // Scatter points
  const scatterData=rows.map(r=>({x:r.angle,y:r.mean}));
  // Regression line evaluated from min to max angle
  const xMin=Math.min(...xs), xMax=Math.max(...xs);
  const xLine=[]; for(let th=xMin; th<=xMax; th+= (xMax-xMin)/100 || 1){xLine.push(th)}
  const lineData=xLine.map(x=>({x, y:a + b*x}));
  rtChart=new Chart(ctxPlot,{
    type:'scatter',
    data:{
      datasets:[
        {label:'Mean RT per angle', data: scatterData, pointRadius:5, borderWidth:0, backgroundColor:'rgba(106,163,255,0.9)'},
        {label:`Fit: RT = ${a.toFixed(1)} + ${b.toFixed(2)}·θ`, data: lineData, type:'line', borderWidth:2, pointRadius:0, fill:false, borderColor:'rgba(200,220,255,0.9)'}
      ]
    },
    options:{
      responsive:true,
      maintainAspectRatio:false,
      scales:{
        x:{title:{display:true,text:'Rotation angle θ (deg)'}},
        y:{title:{display:true,text:'Reaction time (ms)'}}
      },
      plugins:{
        legend:{display:true},
        tooltip:{callbacks:{
          afterLabel:(ctx)=>{const angle=ctx.parsed.x;const row=rows.find(r=>r.angle===angle);return row?`N=${row.n}`:''}
        }}
      }
    }
  });
}

// ---------- CSV export ----------
function toCSV(rows){const header=['pid','trial','timestamp_ms','angle_deg','condition','answer','correct','rt_ms'];const lines=[header.join(',')];for(const r of rows){lines.push([r.pid,r.trial,r.t,r.angle,r.cond,r.answer,r.correct,r.rt_ms].join(','))}return lines.join('\n')}
ui('btn-export').addEventListener('click',()=>{const csv=toCSV(state.data);const blob=new Blob([csv],{type:'text/csv'});const url=URL.createObjectURL(blob);const a=ui('dl');a.href=url;a.download=`mental_rotation_${Date.now()}.csv`;a.style.display='inline-block';a.textContent='Download CSV'});

// ---------- Controls ----------
window.addEventListener('keydown',e=>{if(e.key==='s'||e.key==='S')respond('same');if(e.key==='d'||e.key==='D')respond('diff')});
ui('btn-same').onclick=()=>respond('same');
ui('btn-diff').onclick=()=>respond('diff');
ui('btn-start').onclick=()=>{state.total=Math.max(10,parseInt(ui('ntrials').value)||80);state.trial=0;state.data=[];state.angles=[...([...ui('anglesel').options].filter(o=>o.selected).map(o=>+o.value)||ANGLE_DEFAULTS)];newTrial()};
ui('btn-practice').onclick=()=>{state.total=6;state.trial=0;state.data=[];newTrial()};
ui('btn-shape').onclick=()=>{BASE=genPolyomino(10);MIRROR=mirrorX(BASE);clear();draw3D(ctxL,BASE,{angle:0,...center(canvasL)});draw3D(ctxR,BASE,{angle:0,...center(canvasR)});ui('status').textContent='New base shape generated.'};

// ---------- Initial preview ----------
clear();
draw3D(ctxL,BASE,{angle:0,...center(canvasL)});
draw3D(ctxR,mirrorX(BASE),{angle:0,...center(canvasR)});
ui('status').textContent='Tip: press Start, then answer with S/D as fast as possible.';
</script>
</body>
</html>
