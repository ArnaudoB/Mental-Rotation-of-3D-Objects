<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mental Rotation (Shepard–Metzler style) — Full 3D Replica</title>
  <style>
    :root{
      --bg:#0b0d10; --panel:#121720; --ink:#e8eefc; --muted:#9fb0d0; --accent:#6aa3ff; --ok:#53d17a; --bad:#ff6a6a;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink);} 
    header{padding:16px 20px;border-bottom:1px solid #1c2330;background:linear-gradient(180deg,#0b0d10,#0b0d10 60%,#0e131b);} 
    h1{margin:4px 0 0;font-size:20px;letter-spacing:.2px}
    .wrap{max-width:1100px;margin:0 auto;padding:20px;}
    .grid{display:grid;gap:16px;grid-template-columns:1fr;}
    @media (min-width: 980px){.grid{grid-template-columns: 320px 1fr;}}
    .card{background:var(--panel);border:1px solid #1a2230;border-radius:16px;padding:16px;}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    label{font-size:14px;color:var(--muted)}
    input,select,button{background:#0e1420;color:var(--ink);border:1px solid #1a2230;border-radius:10px;padding:10px 12px;font-size:14px}
    input:disabled,select:disabled,button:disabled{opacity:.6}
    button.primary{background:var(--accent);border-color:#2a62ff;color:white;font-weight:600}
    button.good{background:var(--ok);border-color:#1f9c49;color:#04150b}
    button.bad{background:#2c1414;border-color:#552626;color:#ffbdbd}
    .muted{color:var(--muted);font-size:13px}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #263147;background:#0f1520;color:var(--muted);font-size:12px}
    canvas.stage{width:100%;aspect-ratio:3/2;background:#101624;border:1px solid #1a2230;border-radius:12px;display:block}
    .stage-wrap{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, monospace;background:#0b0f18;border:1px solid #1a2230;padding:2px 6px;border-radius:6px}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{border-bottom:1px solid #1a2230;padding:8px 6px;text-align:right}
    th:nth-child(1),td:nth-child(1){text-align:left}
    .ok{color:var(--ok)}
    .err{color:var(--bad)}
    footer{opacity:.8;font-size:12px;text-align:center;padding:20px}
    .sep{height:1px;background:#1a2230;margin:6px 0 12px}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header>
    <div class="wrap row" style="justify-content:space-between">
      <div>
        <div class="pill">3D replica</div>
        <h1>Mental Rotation Task — Shepard & Metzler (Interactive)</h1>
      </div>
      <div class="muted">Keys: <span class="kbd">S</span> = "Same", <span class="kbd">D</span> = "Different"</div>
    </div>
  </header>

  <div class="wrap grid">
    <section class="card">
      <h3>Experiment setup</h3>
      <div class="row"><label for="pid">Participant ID</label><input id="pid" placeholder="e.g., X21-001" /></div>
      <div class="row"><label for="ntrials">Trials</label><input id="ntrials" type="number" value="80" style="width:100px"/><label for="anglesel">Angles</label><select id="anglesel" multiple size="6" style="min-width:160px"><option>0</option><option>20</option><option>40</option><option>60</option><option>80</option><option>100</option><option>120</option><option>140</option><option>160</option><option>180</option></select></div>
      <div class="row"><label>Conditions</label><label class="row"><input id="cond-same" type="checkbox" checked/> Same</label><label class="row"><input id="cond-diff" type="checkbox" checked/> Different</label></div>
      <div class="row"><button id="btn-shape">Regenerate base shape</button><button id="btn-practice">Practice</button><button id="btn-start" class="primary">Start experiment</button></div>
      <div class="sep"></div><div class="muted" id="status">Ready.</div>
    </section>

    <section class="card">
      <div class="stage-wrap"><canvas id="canvasL" class="stage" width="600" height="400"></canvas><canvas id="canvasR" class="stage" width="600" height="400"></canvas></div>
      <div class="row"><button id="btn-same" class="good">Same (S)</button><button id="btn-diff" class="bad">Different (D)</button><div class="pill" id="trialpill">Trial: –</div><div class="pill" id="anglepill">Angle: –</div><div class="pill" id="modepill">Mode: –</div><div class="pill" id="condpill">Condition: –</div><div class="muted" id="feedback"></div></div>
    </section>

    <section class="card" style="grid-column:1 / -1">
      <h3>Results</h3>
      <div id="summary" class="muted">Run trials to see results.</div>
      <div id="tables"></div>
      <div class="row" style="gap:16px; align-items:flex-start; margin-top:8px">
        <div style="flex:1; min-width:260px">
          <div class="muted" style="margin-bottom:6px">Image-plane rotation</div>
          <canvas id="chartPlane" height="220"></canvas>
        </div>
        <div style="flex:1; min-width:260px">
          <div class="muted" style="margin-bottom:6px">Rotation in depth</div>
          <canvas id="chartDepth" height="220"></canvas>
        </div>
      </div>
      <div class="row" style="margin-top:10px"><button id="btn-export">Export CSV</button><a id="dl" class="pill" href="#" download style="display:none">Download CSV</a></div>
    </section>
  </div>

  <footer>Built with HTML/JS/CSS. 3D Lambertian shading + dual-condition analysis.</footer>

<script>
function ui(id){return document.getElementById(id);} 
function randChoice(arr){return arr[Math.floor(Math.random()*arr.length)];}
function now(){return performance.now();}

// === Polyomino generator ===
function genPolyomino(n=10){const dirs=[[1,0],[-1,0],[0,1],[0,-1]];let cells=new Set(['0,0']);let path=[{x:0,y:0}];let spins=0;while(path.length<n&&spins<5000){spins++;const[dx,dy]=randChoice(dirs);const prev=path[path.length-1];const nx=prev.x+dx,ny=prev.y+dy;const k=`${nx},${ny}`;if(path.length>1){const p2=path[path.length-2];if(p2.x===nx&&p2.y===ny)continue;}if(!cells.has(k)){cells.add(k);path.push({x:nx,y:ny});}}if(path.length<n)return genPolyomino(n);const minx=Math.min(...path.map(p=>p.x)),miny=Math.min(...path.map(p=>p.y));return path.map(p=>({x:p.x-minx,y:p.y-miny}));}
function mirrorX(poly){const maxx=Math.max(...poly.map(p=>p.x));return poly.map(p=>({x:maxx-p.x,y:p.y}));}

// === 3D rotation & projection ===
function rotate3D(x,y,z, ax, ay, az){
  const rx=ax*Math.PI/180, ry=ay*Math.PI/180, rz=az*Math.PI/180;
  const cx=Math.cos(rx), sx=Math.sin(rx), cy=Math.cos(ry), sy=Math.sin(ry), cz=Math.cos(rz), sz=Math.sin(rz);
  // X
  let y1=y*cx - z*sx, z1=y*sx + z*cx, x1=x;
  // Y
  let x2=x1*cy + z1*sy, z2=-x1*sy + z1*cy, y2=y1;
  // Z
  let x3=x2*cz - y2*sz, y3=x2*sz + y2*cz, z3=z2;
  return {x:x3, y:y3, z:z3};
}
function project3D(x,y,z, ax, ay, az, scale){
  const r=rotate3D(x,y,z, ax, ay, az);
  return {x:r.x*scale, y:r.y*scale, z:r.z*scale};
}
function center(canvas){const s=Math.min(canvas.width,canvas.height)/8;return{offsetX:canvas.width/2,offsetY:canvas.height/2,scale:s};}

// === 3D shaded voxel renderer ===
function draw3D(ctx,poly,{yaw=0,roll=0, offsetX,offsetY,scale}){
  const ax=30; // fixed tilt
  const COL={top:[255,234,170],right:[248,205,120],left:[221,168,82],front:[236,190,110],back:[200,154,70],bottom:[160,120,55]};
  const EDGE='rgba(255,255,255,0.85)',ALPHA=0.98,AMBIENT=0.35,DIFFUSE=0.65;
  let L={x:0.3,y:0.6,z:1.0};const Lnorm=Math.hypot(L.x,L.y,L.z);L={x:L.x/Lnorm,y:L.y/Lnorm,z:L.z/Lnorm};
  const N_FACE={top:{x:0,y:0,z:1},bottom:{x:0,y:0,z:-1},left:{x:-1,y:0,z:0},right:{x:1,y:0,z:0},front:{x:0,y:1,z:0},back:{x:0,y:-1,z:0}};
  function shade(rgb,key){const n=rotate3D(N_FACE[key].x,N_FACE[key].y,N_FACE[key].z, ax, yaw, roll);const nl=Math.hypot(n.x,n.y,n.z)||1;const nn={x:n.x/nl,y:n.y/nl,z:n.z/nl};const ndotl=Math.max(0,nn.x*L.x+nn.y*L.y+nn.z*L.z);const k=AMBIENT+DIFFUSE*ndotl;return`rgba(${Math.round(rgb[0]*k)},${Math.round(rgb[1]*k)},${Math.round(rgb[2]*k)},${ALPHA})`;}
  function proj(pt){return project3D(pt.x,pt.y,pt.z, ax, yaw, roll, scale);} 
  function drawPoly(pts,fill){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();ctx.fillStyle=fill;ctx.fill();ctx.strokeStyle=EDGE;ctx.lineWidth=1.2;ctx.stroke();}
  const mx=poly.reduce((s,p)=>s+p.x,0)/poly.length, my=poly.reduce((s,p)=>s+p.y,0)/poly.length;
  const cubes=poly.map(p=>({x:p.x-mx,y:p.y-my,z:0}));
  const faces=[];
  for(const c of cubes){
    const x=c.x-0.5,y=c.y-0.5,z=c.z-0.5;
    const v=[{x:x,y:y,z:z},{x:x+1,y:y,z:z},{x:x+1,y:y+1,z:z},{x:x,y:y+1,z:z},{x:x,y:y,z:z+1},{x:x+1,y:y,z:z+1},{x:x+1,y:y+1,z:z+1},{x:x,y:y+1,z:z+1}].map(proj);
    const F=[{key:'top',idx:[4,5,6,7]},{key:'bottom',idx:[0,1,2,3]},{key:'left',idx:[0,4,7,3]},{key:'right',idx:[1,5,6,2]},{key:'front',idx:[2,3,7,6]},{key:'back',idx:[0,1,5,4]}];
    for(const f of F){const pts=f.idx.map(i=>v[i]);const zavg=pts.reduce((s,p)=>s+p.z,0)/pts.length;faces.push({pts,key:f.key,zavg});}
  }
  faces.sort((a,b)=>a.zavg-b.zavg);
  ctx.save();ctx.translate(offsetX,offsetY);for(const f of faces) drawPoly(f.pts,shade(COL[f.key],f.key));ctx.restore();
}

// === Experiment logic ===
const ANGLE_DEFAULTS=[0,20,40,60,80,100,120,140,160,180];
let BASE=genPolyomino(10),MIRROR=mirrorX(BASE);
const canvasL=ui('canvasL'),canvasR=ui('canvasR');const ctxL=canvasL.getContext('2d'),ctxR=canvasR.getContext('2d');
let chartPlane=null, chartDepth=null;
const state={trial:0,total:0,angles:[...ANGLE_DEFAULTS],data:[],rtStart:null,angle:0,condition:null, mode:null};
function clearStage(){ctxL.clearRect(0,0,canvasL.width,canvasL.height);ctxR.clearRect(0,0,canvasR.width,canvasR.height);} 
function newTrial(){
  if(state.trial>=state.total) return finish();
  state.trial++;
  const angle=randChoice(state.angles);
  const cond=(Math.random()<0.5?'same':'diff');
  const mode=(Math.random()<0.5?'plane':'depth');
  state.condition=cond; state.angle=angle; state.mode=mode;
  clearStage();
  const cL=center(canvasL), cR=center(canvasR);
  draw3D(ctxL, BASE, {yaw:0, roll:0, ...cL});
  if(mode==='depth'){
    draw3D(ctxR, cond==='same'?BASE:MIRROR, {yaw:angle, roll:0, ...cR});
  }else{
    draw3D(ctxR, cond==='same'?BASE:MIRROR, {yaw:0, roll:angle, ...cR});
  }
  state.rtStart=now();
  ui('trialpill').textContent=`Trial: ${state.trial}/${state.total}`;
  ui('anglepill').textContent=`Angle: ${angle}°`;
  ui('modepill').textContent=`Mode: ${mode}`;
  ui('condpill').textContent=`Condition: ${cond}`;
  ui('feedback').textContent='';
}
function respond(ans){
  if(!state.rtStart) return;
  const rt=now()-state.rtStart; state.rtStart=null;
  const correct=(ans===state.condition);
  state.data.push({pid:ui('pid').value.trim()||'NA',trial:state.trial,t:Date.now(),angle:state.angle,cond:state.condition,mode:state.mode,answer:ans,correct:correct?1:0,rt_ms:Math.round(rt)});
  ui('feedback').innerHTML=correct?`<span class='ok'>Correct</span> (${Math.round(rt)} ms)`: `<span class='err'>Wrong</span> (${Math.round(rt)} ms)`;
  setTimeout(newTrial,400);
}
function finish(){ ui('status').textContent=`Finished ${state.data.length} trials.`; summarize(); }

// === Stats + Plot ===
const mean=a=>a.reduce((s,x)=>s+x,0)/Math.max(1,a.length);
a=>{ if(a.length<=1)return 0; const m=mean(a); return Math.sqrt(mean(a.map(x=>(x-m)*(x-m)))); };
function sd(a){ if(a.length<=1) return 0; const m=mean(a); return Math.sqrt(mean(a.map(x=>(x-m)*(x-m)))); }
function linreg(x,y){ if(x.length<=1) return {a:mean(y)||0,b:0,r2:0}; const mx=mean(x), my=mean(y); let num=0, den=0, sst=0; for(let i=0;i<x.length;i++){ const dx=x[i]-mx, dy=y[i]-my; num+=dx*dy; den+=dx*dx; sst+=(y[i]-my)*(y[i]-my);} const b=den===0?0:num/den; const a=my-b*mx; let ssr=0; for(let i=0;i<x.length;i++){ const yhat=a+b*x[i]; ssr+=(yhat-my)*(yhat-my);} const r2= sst===0?0:ssr/sst; return {a,b,r2}; }
function summarize(){
  const sameCorrect=state.data.filter(d=>d.cond==='same'&&d.correct===1);
  if(!sameCorrect.length){ ui('summary').textContent='No correct SAME trials yet. Run more trials.'; ui('tables').innerHTML=''; if(chartPlane){chartPlane.destroy(); chartPlane=null;} if(chartDepth){chartDepth.destroy(); chartDepth=null;} return; }
  const bucket=(mode)=>{
    const arr=sameCorrect.filter(d=>d.mode===mode);
    const byAngle=new Map(); for(const d of arr){ if(!byAngle.has(d.angle)) byAngle.set(d.angle,[]); byAngle.get(d.angle).push(d.rt_ms); }
    const rows=[...byAngle.entries()].map(([ang,list])=>({angle:+ang,n:list.length,mean:mean(list),sd:sd(list)})).sort((a,b)=>a.angle-b.angle);
    const xs=rows.map(r=>r.angle), ys=rows.map(r=>r.mean);
    const fit=linreg(xs,ys);
    return {rows,xs,ys,fit,count:arr.length};
  };
  const P=bucket('plane');
  const D=bucket('depth');
  ui('summary').textContent=`SAME & correct → plane: N=${P.count}, depth: N=${D.count}. Slopes (ms/deg): plane b=${P.fit.b.toFixed(2)}, depth b=${D.fit.b.toFixed(2)}.`;
  ui('tables').innerHTML = [
    ['plane',P],['depth',D]
  ].map(([name,B])=>{
    return `<div style="margin:8px 0"><span class="pill">${name}</span> a=${B.fit.a.toFixed(1)} ms, b=${B.fit.b.toFixed(2)} ms/deg, R²=${B.fit.r2.toFixed(3)}</div>`+
    '<table><thead><tr><th>Angle (°)</th><th>N</th><th>Mean RT (ms)</th><th>SD (ms)</th></tr></thead><tbody>'+
    B.rows.map(r=>`<tr><td>${r.angle}</td><td>${r.n}</td><td>${r.mean.toFixed(1)}</td><td>${r.sd.toFixed(1)}</td></tr>`).join('')+
    '</tbody></table>';
  }).join('');

  // Charts
  const ctxP=document.getElementById('chartPlane').getContext('2d');
  const ctxD=document.getElementById('chartDepth').getContext('2d');
  if(chartPlane){chartPlane.destroy();} if(chartDepth){chartDepth.destroy();}
  const mkLine=(xs,a,b)=>{ if(xs.length===0) return []; const xMin=Math.min(...xs), xMax=Math.max(...xs); const xLine=[]; for(let t=xMin; t<=xMax; t+=(xMax-xMin)/100||1){ xLine.push(t);} return xLine.map(x=>({x, y:a+b*x})); };
  chartPlane=new Chart(ctxP,{ type:'scatter', data:{ datasets:[ {label:'Mean RT per angle (plane)', data:P.rows.map(r=>({x:r.angle,y:r.mean})), pointRadius:5, borderWidth:0, backgroundColor:'rgba(255,220,120,0.95)'}, {label:`Fit: RT = ${P.fit.a.toFixed(1)} + ${P.fit.b.toFixed(2)}·θ`, data:mkLine(P.xs,P.fit.a,P.fit.b), type:'line', borderWidth:2, pointRadius:0, fill:false, borderColor:'rgba(255,255,255,0.9)'} ] }, options:{ responsive:true, maintainAspectRatio:false, scales:{ x:{title:{display:true,text:'θ (deg) — plane'}}, y:{title:{display:true,text:'RT (ms)'}} } } });
  chartDepth=new Chart(ctxD,{ type:'scatter', data:{ datasets:[ {label:'Mean RT per angle (depth)', data:D.rows.map(r=>({x:r.angle,y:r.mean})), pointRadius:5, borderWidth:0, backgroundColor:'rgba(190,230,255,0.95)'}, {label:`Fit: RT = ${D.fit.a.toFixed(1)} + ${D.fit.b.toFixed(2)}·θ`, data:mkLine(D.xs,D.fit.a,D.fit.b), type:'line', borderWidth:2, pointRadius:0, fill:false, borderColor:'rgba(255,255,255,0.9)'} ] }, options:{ responsive:true, maintainAspectRatio:false, scales:{ x:{title:{display:true,text:'θ (deg) — depth'}}, y:{title:{display:true,text:'RT (ms)'}} } } });
}

// === CSV export ===
function toCSV(rows){ const header=['pid','trial','timestamp_ms','angle_deg','condition','mode','answer','correct','rt_ms']; const lines=[header.join(',')]; for(const r of rows){ lines.push([r.pid,r.trial,r.t,r.angle,r.cond,r.mode,r.answer,r.correct,r.rt_ms].join(',')); } return lines.join('\n'); }
ui('btn-export').addEventListener('click',()=>{ const csv=toCSV(state.data); const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=ui('dl'); a.href=url; a.download=`mental_rotation_${Date.now()}.csv`; a.style.display='inline-block'; a.textContent='Download CSV'; });

// === Controls ===
window.addEventListener('keydown',e=>{ if(e.key==='s'||e.key==='S')respond('same'); if(e.key==='d'||e.key==='D')respond('diff');});
ui('btn-same')?.addEventListener('click',()=>respond('same'));
ui('btn-diff')?.addEventListener('click',()=>respond('diff'));
ui('btn-start').onclick=()=>{ state.total=Math.max(10,parseInt(ui('ntrials').value)||80); state.trial=0; state.data=[]; const chosen=[...ui('anglesel').options].filter(o=>o.selected).map(o=>+o.value); state.angles=chosen.length?chosen:[...ANGLE_DEFAULTS]; newTrial(); };
ui('btn-practice').onclick=()=>{ state.total=6; state.trial=0; state.data=[]; newTrial(); };
ui('btn-shape').onclick=()=>{ BASE=genPolyomino(10); MIRROR=mirrorX(BASE); clearStage(); const cL=center(canvasL), cR=center(canvasR); draw3D(ctxL,BASE,{yaw:0,roll:0,...cL}); draw3D(ctxR,BASE,{yaw:0,roll:0,...cR}); ui('status').textContent='New base shape generated.' };

// === Initial preview ===
clearStage(); const cL0=center(canvasL), cR0=center(canvasR); draw3D(ctxL,BASE,{yaw:0,roll:0,...cL0}); draw3D(ctxR,MIRROR,{yaw:0,roll:0,...cR0}); ui('status').textContent='Tip: press Start, then answer with S/D as fast as possible.';
</script>
</body>
</html>
